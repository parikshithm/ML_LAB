# -*- coding: utf-8 -*-
"""Model_Train.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ok28EhCsghb2n_rDjhLcnwf3wB4byFW9
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv('laptop_data.csv')

df.head()

df.isnull().sum()

df.duplicated().sum()

df.drop(columns=['Unnamed: 0'], inplace= True)

df.head()

df['Ram'] = df['Ram'].str.replace('GB', '')
df['Weight'] = df['Weight'].str.replace('kg', '')

df['Ram'] = df['Ram'].astype('int32')
df['Weight'] = df['Weight'].astype('float32')

df.info()

df['Touchscreen'] = df['ScreenResolution'].apply(lambda x:1 if 'Touchscreen' in x else 0)
df.sample(n=5)

df['IPS'] = df['ScreenResolution'].apply(lambda x:1 if 'IPS' in x else 0)
df.sample(n=5)

df['x_resolution'] = df['ScreenResolution'].apply(lambda x:x[x.index('x') - 4 :  x.index('x')])

df.head()

df['y_resolution'] = df['ScreenResolution'].apply(lambda x:x.split('x')[-1])

df.head()

df['x_resolution'] = df['x_resolution'].astype('int')
df['y_resolution'] = df['y_resolution'].astype('int')

import re
def extract_storage_size(memory):
    ssd_size = re.search(r'(\d+)(?:GB|TB) SSD', memory)
    hdd_size = re.search(r'(\d+)(?:GB|TB) HDD', memory)
    hybrid_size = re.search(r'(\d+(?:\.\d+)?)TB Hybrid', memory)
    flash_size = re.search(r'(\d+)GB Flash Storage', memory)

    ssd_size_gb = int(float(ssd_size.group(1)) * 1024) if ssd_size and 'TB' in ssd_size.group() else int(ssd_size.group(1)) if ssd_size else 0
    hdd_size_gb = int(hdd_size.group(1)) * 1024 if hdd_size and 'TB' in hdd_size.group() else int(hdd_size.group(1)) if hdd_size else 0
    hybrid_size_gb = int(float(hybrid_size.group(1)) * 1024) if hybrid_size else 0
    flash_size_gb = int(flash_size.group(1)) if flash_size else 0

    return ssd_size_gb, hdd_size_gb, hybrid_size_gb, flash_size_gb

df['SSD'], df['HDD'], df['Hybrid'], df['Flash Storage'] = zip(*df['Memory'].apply(extract_storage_size))
df.sample(5)

"""### **For CPU NAME**"""

# Splitting the Cpu [targeting the space in the cpu names] [then take the first 3 words to ake it easy]
# Take the first 3 words before the 3 its will be conflicted because intel core the same first 2
df['Cpu Name'] = df['Cpu'].apply(lambda x: " ".join(x.split()[0:3]))

df.head()

numerical_cols = df.select_dtypes(include=np.number).columns.tolist()

for col in numerical_cols:
    plt.figure(figsize=(8, 4))
    sns.boxplot(x=df[col])
    plt.title(f'Boxplot of {col}')
    plt.show()

"""# **To prepare the columns inorder to build the regression model**"""

df_bkp=df.copy()
df.drop(columns=['Cpu','ScreenResolution','Memory'], inplace=True)
df.head()

df.info()

numerical_cols = df.select_dtypes(include=np.number).columns.tolist()
corr_matrix = df[numerical_cols].corr()

plt.figure(figsize=(12, 10))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of Numerical Columns')
plt.show()

# prompt: drop one of the two columns that have a correlation greater than 0.6 except the column Price

columns_to_drop = []
for i in range(len(corr_matrix.columns)):
    for j in range(i):
        if abs(corr_matrix.iloc[i, j]) > 0.6 and corr_matrix.columns[i] != 'Price' and corr_matrix.columns[j] != 'Price':
            col_name = corr_matrix.columns[i]
            if col_name not in columns_to_drop:
                columns_to_drop.append(col_name)

df.drop(columns=columns_to_drop, inplace=True)
print(f"Dropped columns: {columns_to_drop}")
df.head()

# prompt: standardize the data set except for these columns " 'Company', 'TypeName', 'OpSys', 'Gpu', 'Cpu Name"

##from sklearn.preprocessing import StandardScaler

##columns_to_standardize = [col for col in df.columns if col not in ['Company', 'TypeName', 'OpSys', 'Gpu', 'Cpu Name','Price']]

##scaler = StandardScaler()
##df[columns_to_standardize] = scaler.fit_transform(df[columns_to_standardize])
##df.head()

from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error
from sklearn.pipeline import Pipeline
import numpy as np

# Splitting data into features and target
X = df.drop(columns=['Price'])
y = np.log(df['Price'])  # Log-transform the target variable

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=2)

# Define numerical and categorical columns
numerical_features = [col for col in X.columns if col not in ['Company', 'TypeName', 'OpSys', 'Gpu', 'Cpu Name']]
categorical_features = ['Company', 'TypeName', 'OpSys', 'Gpu', 'Cpu Name']

# Preprocessing: Standardizing numerical features, one-hot encoding categorical features
preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numerical_features),  # Standardize numerical features
        ('cat', OneHotEncoder(sparse_output=False, handle_unknown='ignore'), categorical_features)  # One-hot encode categorical features
    ]
)

# Linear Regression pipeline
pipeline = Pipeline([
    ('preprocessor', preprocessor),  # Preprocessing step
    ('regressor', LinearRegression())  # Linear Regression
])

# Fit the pipeline to the training data
pipeline.fit(X_train, y_train)

# Predict on the test set
y_pred = pipeline.predict(X_test)

# Evaluate the model
print(f"R2 Score: {r2_score(y_test, y_pred):.4f}")
print(f"Mean Absolute Error: {mean_absolute_error(y_test, y_pred):.4f}")


import pickle
pickle.dump(pipeline, open('model.pkl','wb'))

'''
print("Possibility of heart disease is =",model.predict([['HP','Gaming',15.6,16,'NVIDIA GeForce GTX 1050',1,]])) # we are giving input here to predict the performance of our model


input_data = pd.DataFrame({
    'Company': ['HP'],                # Example categorical feature
    'TypeName': ['Gaming'],           # Example categorical feature
    'Inches': [15.6],                 # Example numerical feature
    'Ram': [16],                      # Example numerical feature
    'Gpu': ['NVIDIA GeForce GTX 1050'],  # Example categorical feature
    'Touchscreen': [1],               # 1 for Touchscreen, 0 otherwise
    'IPS': [1],                       # 1 for IPS, 0 otherwise
    'x_resolution': [1920],           # Example numerical feature
    'HDD': [0],                       # Example storage feature
    'Hybrid': [0],                    # Example storage feature
    'Flash Storage': [0],             # Example storage feature
    'Cpu Name': ['Intel Core i7']     # Example categorical feature
})

# Preprocess the input using the pipeline's transformer
preprocessed_input = transformer.transform(input_data)

# Predict price
predicted_price = pipeline.predict(preprocessed_input)
print("Predicted log price of the laptop is =", predicted_price)

# If needed, exponentiate to get back the original price scale
original_price = np.exp(predicted_price)
print("Predicted actual price of the laptop is =", original_price)

#Model is ready. Let us check the coefficients, stored as reg.coef_.
#These are a, b, and c from our equation. 
#Intercept is stored as reg.intercept
'''